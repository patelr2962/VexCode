#pragma config(Sensor, in1,    leftPmeter,     sensorPotentiometer)
#pragma config(Sensor, in2,    rightPmeter,    sensorPotentiometer)
#pragma config(Sensor, in3,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           clawMotor,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftBase,      tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl1)
#pragma config(Motor,  port3,           leftLift,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightBase,     tmotorVex393_MC29, openLoop, driveRight, encoderPort, dgtl3)
#pragma config(Motor,  port10,          intakeMotor,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int gyrooutput;
int gyrocurrentvalue = 0;

/*void moveBase (int speed)
{
	motor[leftBase] = speed;
	motor[rightBase] = speed;
}*/

void moveRightBase (int speed)
{
	motor[rightBase] = speed;
}

void moveLeftBase (int speed)
{
	motor[leftBase] = speed;
}

/* void turnBase (int speed) //positive is clockwise
{
	motor[leftBase] = speed;
	motor[rightBase] = -speed;
} */

void moveBase(int speed)
{
	motor[leftBase] = speed;
	motor[rightBase] = speed;
}

/*void fixgyro()
{
	SensorFullCount[in3] = 36000;
}*/

void resetGyro(int value = 0)
{
	gyrocurrentvalue = SensorValue[Gyro] + value;
}

/*void GyroProcessingBlock()
{
	while (true)
	{
		gyrooutput = SenorValue[Gyro] - gyrocurrentvalue;
		wait1Msec(20);
	}
}*/

//reading is in ticks -- 627.2 ticks/revolution (393)
//1 turn of wheels -- 5 inch wheels = 627.2*2 ticks
//5*pi inches =  627.2*2 ticks

//ticks per inch = (627.2*2)/(5*pi) = 79.8575842458
int inchToTicks (float inch)
{
	int ticks;
	ticks = inch*79.8575842458;
	return ticks;
}

int fixTimerValue (float rawSeconds)
{
	int milliseconds;
	milliseconds = rawSeconds*1000;
	if (milliseconds < 250)
	{
		milliseconds = 250;
	}
	return milliseconds;
}
//>>>>>>>>>>>>>>>>>>>>----------0----------<<<<<<<<<<<<<<<<<<<<

void PIDBaseControl (float target, float waitTime, float maxPower = 1)
{
	float Kp = 3.1/*Find amount during tests*/;
	float Ki = 4.1/*Find amount during tests*/;
	float Kd = 5.9/*Find amount during tests*/;

	int error;

	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;
	int finalPower;


	float integralActiveZone = inchToTicks(2/*Find amount during tests*/);
	float integralPowerLimit = 50/(Ki*maxPower);

	//Error Correction
	float Kp_C = 4/*Find amount during tests*/;

	bool timerBool = true;

	SensorValue[leftEncoder] = 0;
	SensorValue[rightEncoder] = 0;

	resetGyro();
	clearTimer(T1);

	while(time1[T1] < fixTimerValue(waitTime))
	{

	error = inchToTicks(target)-(SensorValue[leftBase]+SensorValue[rightBase]);

		proportion = Kp*error;

		if (0 < error < integralActiveZone && error != 0)
		{
			integralRaw = integralRaw+error;
		}
		else if (error == 0)
		{
			integralRaw = 0;
		}
		else
		{
			integralRaw = 0;
		}
		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		if (integralRaw < -integralPowerLimit)
		{
			integralRaw = -integralPowerLimit;
		}
		integral = Ki*integralRaw;

		derivative = Kd*(error-lastError);
		lastError = error;

		if (error == 0)
		{
			derivative = 0;
		}

		finalPower = proportion+integral+derivative; //(P+I+D)

		if (finalPower > maxPower*127)
		{
			finalPower = maxPower*127;
		}
		else if (finalPower < -maxPower*127)
		{
			finalPower = -maxPower*127;
		}

		int error_drift;
		error_drift = gyrooutput;

		int driveDeduction;
		driveDeduction = Kp_C*error_drift;

		float driveLeft;
		float driveRight;

		driveLeft = finalPower+driveDeduction;
		driveRight = finalPower-driveDeduction;

		moveLeftBase(driveLeft);
		moveRightBase(driveRight);

		//When error is 30, the error in inches is -0.3
		wait1Msec(40);

		if (error < 30)
		{
			timerBool = false;
		}
		if (timerBool)
		{
			clearTimer(T1);
		}
	}
	moveBase(0);
}

void PIDBaseGyroTurn (int target, int waittime, float maxPower = 1, int type = 0)
{
	float Kp = 0.45/*Find amount during tests*/;
	float Kd = 0.5/*Find amount during tests*/;
	float Ki = 0.01/*Find amount during tests*/;

	float error = 500;
	int lastError;

	float proportion;
	float derivative;
	float integralRaw;
	float integral;
	float finalPower;

	float  integralPowerLimit = 30/(Ki*maxPower);
	int integralActiveZone = 500;

	int timer = 0;

	if (type == 0)
	{
		resetGyro();
	}
	else if (type == 1)
	{
		resetGyro(SensorValue[Gyro]);
	}

	clearTimer(T1);

	while (time1[T1] < waittime)
	{
		error = target-gyrooutput;       //calculate error

		proportion = Kp*error;

		derivative = Kd*(error-lastError);            //calculate the derivative
		lastError  = error;

		if(0 < error < integralActiveZone && error != 0)
		{
			integralRaw = integralRaw+error;
		}
		else if (error == 0)
		{
			integralRaw = 0;
		}
		else
		{
			integralRaw = 0;
		}

		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		else if (integralRaw < -(integralPowerLimit))
		{
			integralRaw = -(integralPowerLimit);
		}

		integral = Ki*integralRaw;

		finalPower = proportion+derivative+integral;

		if (finalPower > maxPower*127)
		{
			finalPower = maxPower*127;
		}
		else if (finalPower < -maxPower*127)
		{
			finalPower = -maxPower*127;
		}

		turnLeft(finalPower);

		wait1Msec(20);

		if (0 < error < 50)
		{
			timer = 1;
		}
		if (timer == 0)
		{
			clearTimer(T1);
		}
	}
	moveBase(0);
}

task main()
{
	PIDBaseControl(12,1);
	PIDBaseGyroTurn(-900,1000,0.8,1);
	while(true)
	{
		wait1Msec(20);
	}
}
