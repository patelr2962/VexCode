#pragma config(Sensor, in3,    Gyro,           sensorGyro)
#pragma config(Sensor, in4,    leftIpot,       sensorPotentiometer)
#pragma config(Sensor, in5,    rightIpot,      sensorPotentiometer)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           clawMotor,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftBase,      tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl1)
#pragma config(Motor,  port3,           leftLift,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port4,           leftIntake,    tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port6,           rightLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightBase,     tmotorVex393_MC29, openLoop, driveRight, encoderPort, dgtl3)
#pragma config(Motor,  port8,           rightIntake,   tmotorVex393_MC29, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

// This code is for the VEX cortex platform
#pragma platform(VEX2)

// Select Download method as "competition"
#pragma competitionControl(Competition)

//Main competition background code...do not modify!
#include "Vex_Competition_Includes.c"

/*---------------------------------------------------------------------------*/
/*                          Pre-Autonomous Functions                         */
/*                                                                           */
/*  You may want to perform some actions before the competition starts.      */
/*  Do them in the following function.  You must return from this function   */
/*  or the autonomous and usercontrol tasks will not be started.  This       */
/*  function is only called once after the cortex has been powered on and    */
/*  not every time that the robot is disabled.                               */
/*---------------------------------------------------------------------------*/

void pre_auton()
{
  // Set bStopTasksBetweenModes to false if you want to keep user created tasks
  // running between Autonomous and Driver controlled modes. You will need to
  // manage all user created tasks if set to false.
  bStopTasksBetweenModes = true;

	// Set bDisplayCompetitionStatusOnLcd to false if you don't want the LCD
	// used by the competition include file, for example, you might want
	// to display your team name on the LCD in this function.
	// bDisplayCompetitionStatusOnLcd = false;

  // All activities that occur before the competition starts
  // Example: clearing encoders, setting servo positions, ...
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              Autonomous Task                              */
/*                                                                           */
/*  This task is used to control your robot during the autonomous phase of   */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/
/*Index:

Joystick Mapping:

Joystick 1-

Channel 1: Base/2
Channel 2: Base/2
Channel 3: Base
Channel 4: Base
Channel 5:
U = Intake up
D = Intake Down
Channel 6:
U =
D =
Channel 7:
U =
R =
D =
L =
Channel 8:
U =
R =
D =
L =

Joystick 2-

Channel 1:
Channel 2:
Channel 3:
Channel 4:
Channel 5:
U = 9 Cones
D = 10 Cones
Channel 6:
U = 11 Cones
D = 12 Cones
Channel 7:
U = 1 Cone
R = 2 Cones
D = 3 Cones
L = 4 Cones
Channel 8:
U = 5 Cones
R = 6 Cones
D = 7 Cones
L = 8 Cones
*/

/*//Potentiometer based straightening
void liftStraight()
{
int highLift;
highLift = 80;

int normLift;
normLift = 93;

if(SensorValue[] > SensorValue[])
{
motor[leftLift] = highLift;
motor[rightLift] = normLift;
}
if(SensorValue[] < SensorValue[])
{
motor[leftLift] = normLift;
motor[rightLift] = highLift;
}
if(SensorValue[] == SensorValue[])
{
motor[leftLift] = normLift;
motor[rightLift] = normLift;
}
}*/
void moveBase (int speed)
{
	motor[leftBase] = speed;
	motor[rightBase] = speed;
}

void moveRightBase (int speed)
{
	motor[rightBase] = speed;
}

void moveLeftBase (int speed)
{
	motor[leftBase] = speed;
}

void turnBase (int speed) //positive is clockwise
{
	motor[leftBase] = speed;
	motor[rightBase] = -speed;
}
//reading is in ticks -- 627.2 ticks/revolution (393)
//1 turn of wheels -- 5 inch wheels = 627.2*2 ticks
//5*pi inches =  627.2*2 ticks

//ticks per inch = (627.2*2)/(5*pi) = 79.8575842458
int inchesToTick (float inch)
{
	int ticks;
	ticks = inch*79.8575842458;
	return ticks;
}

int degreesToTicks (float degree)
{
	int ticksPerTurn = 4/*Find amount during tests*/;
	int ticks = degree*ticksPerTurn/360;
	return ticks;
}

int fixTimerValue (float rawSeconds)
{
	int milliseconds;
	milliseconds = rawSeconds*1000;
	if (milliseconds < 250)
	{
		milliseconds = 250;
	}
	return milliseconds;
}
//>>>>>>>>>>>>>>>>>>>>----------0----------<<<<<<<<<<<<<<<<<<<<

void PIDBaseControl (float target, float waitTime, float maxPower = 1)
{
	float Kp = 4/*Find amount during tests*/;
	float Ki = 3/*Find amount during tests*/;
	float Kd = 2/*Find amount during tests*/;

	int error;

	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;


	float integralActiveZone = inchesToTick(7/*Find amount during tests*/);
	float integralPowerLimit = 50/Ki;

	int finalPower;

	//Error Correction
	float Kp_C = 0.01;
	int error_drift;
	float proportion_drift;

	bool timerBool = true;

	nMotorEncoder[leftBase] = 0;
	nMotorEncoder[rightBase] = 0;

	clearTimer(T1);

	while(time1[T1] < fixTimerValue(waitTime))
	{

		error = inchesToTick(target) - (nMotorEncoder[leftBase]+nMotorEncoder[rightBase]);

		proportion = Kp*error;

		if (abs(error) < integralActiveZone && error != 0)
		{
			integralRaw = integralRaw+error;
		}
		else
		{
			integralRaw = 0;
		}
		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		if (integralRaw < -integralPowerLimit)
		{
			integralRaw = -integralPowerLimit;
		}
		integral = Ki*integralRaw;

		derivative = Kd*(error-lastError);
		lastError = error;

		if (error == 0)
		{
			derivative = 0;
		}

		finalPower = proportion+integral+derivative; //(P+I+D)

		if (finalPower > maxPower*127)
		{
			finalPower = maxPower*127;
		}
		else if (finalPower < -maxPower*127)
		{
			finalPower = -maxPower*127;
		}

		error_drift = nMotorEncoder[rightBase]-nMotorEncoder[leftBase];
		proportion_drift = Kp_C*error_drift;

		moveLeftBase(finalPower+proportion_drift);
		moveRightBase(finalPower-proportion_drift);

		//When error is 30, the error in inches is -0.3
		wait1Msec(40);

		if (error < 30)
		{
			timerBool = false;
		}
		if (timerBool)
		{
			clearTimer(T1);
		}
	}
	moveBase(0);
}

void PIDBaseTurn (int target, float waitTime, float maxPower = 1)
{
	float Kp = 3/*Find amount during tests*/;
	float Ki = 4/*Find amount during tests*/;
	float Kd = 5/*Find amount during tests*/;

	int error;

	float proportion;
	int integralRaw;
	float integral;
	int lastError;
	int derivative;


	float integralActiveZone = inchesToTick(7/*Find amount during tests*/);
	float integralPowerLimit = 50/Ki;

	int finalPower;

	bool timerBool = true;

	nMotorEncoder[leftBase] = 0;
	nMotorEncoder[rightBase] = 0;

	clearTimer(T1);

	while(time1[T1] < fixTimerValue(waitTime))
	{

		error = degreesToTicks(target) - (nMotorEncoder[leftBase]-nMotorEncoder[rightBase]);

		proportion = Kp*error;

		if (abs(error) < integralActiveZone && error != 0)
		{
			integralRaw = integralRaw+error;
		}
		else
		{
			integralRaw = 0;
		}
		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		if (integralRaw < -integralPowerLimit)
		{
			integralRaw = -integralPowerLimit;
		}
		integral = Ki*integralRaw;

		derivative = Kd*(error-lastError);
		lastError = error;

		if (error == 0)
		{
			derivative = 0;
		}

		finalPower = proportion+integral+derivative; //(P+I+D)

		if (finalPower > maxPower*127)
		{
			finalPower = maxPower*127;
		}
		else if (finalPower < -maxPower*127)
		{
			finalPower = -maxPower*127;
		}

		turnBase(finalPower);

		//When error is 30, the error in inches is -0.3
		wait1Msec(40);

		if (error < 30)
		{
			timerBool = false;
		}
		if (timerBool)
		{
			clearTimer(T1);
		}
	}
	turnBase(0);
}

void intakeStraightUp()
{
	int highBar;
	highBar = 50;

	int normBar;
	normBar = 63;
	if(SensorValue[leftIpot] < 900)
	{
		if(SensorValue[leftIpot] > SensorValue[rightIpot])
		{
			motor[leftIntake] = highBar;
			motor[rightIntake] = normBar;
		}
		if(SensorValue[leftIpot] < SensorValue[rightIpot])
		{
			motor[leftIntake] = normBar;
			motor[rightIntake] = highBar;
		}
		if(SensorValue[leftIpot] == SensorValue[rightIpot])
		{
			motor[leftIntake] = normBar;
			motor[rightIntake] = normBar;
		}
	}
	else
	{
		motor[leftIntake] = 0;
		motor[rightIntake] = 0;
	}
}

void intakeStraightDown()
{
	int highBarNeg;
	highBarNeg = -50;

	int normBarNeg;
	normBarNeg = -63;

	if(SensorValue[leftIpot] > 550)
	{
		if(SensorValue[leftIpot] > SensorValue[rightIpot])
		{
			motor[leftIntake] = highBarNeg;
			motor[rightIntake] = normBarNeg;
		}
		if(SensorValue[leftIpot] < SensorValue[rightIpot])
		{
			motor[leftIntake] = normBarNeg;
			motor[rightIntake] = highBarNeg;
		}
		if(SensorValue[leftIpot] == SensorValue[rightIpot])
		{
			motor[leftIntake] = normBarNeg;
			motor[rightIntake] = normBarNeg;
		}
	}
	else
	{
		motor[leftIntake] = 0;
		motor[rightIntake] = 0;
	}
}

/*
//Encoder based straightening
void moveStraight()
{
int quickMotor;
quickMotor = 50;

int normMotor;
normMotor = 63;

if(SensorValue[leftEncoder] > SensorValue[rightEncoder])
{
motor[leftBase] = quickMotor;
motor[rightBase] = normMotor;
}
if(SensorValue[leftEncoder] < SensorValue[rightEncoder])
{
motor[leftBase] = normMotor;
motor[rightBase] = quickMotor;
}
if(SensorValue[leftEncoder] == SensorValue[rightEncoder])
{
motor[leftBase] = normMotor;
motor[rightBase] = normMotor;
}
}

//Encoder clearing function
void clearEncoders()
{
SensorValue[leftEncoder] = 0;
SensorValue[rightEncoder] = 0;
}
*/
task autonomous()
{
		PIDBaseControl(24,1,1);
		PIDBaseTurn(90,1);
		PIDBaseControl(12,1,1);
		PIDBaseTurn(90,1);
		PIDBaseControl(12,1,1);
		PIDBaseTurn(-90,1);
		intakeStraightDown();
		PIDBaseControl(12,1,1);
		intakeStraightUp();
		PIDBaseTurn(180,1);
		PIDBaseControl(12,1,1);
		PIDBaseTurn(45,1);
		PIDBaseControl(12,1,1);
		PIDBaseTurn(90,1);
		PIDBaseControl(12,1,1);
  AutonomousCodePlaceholderForTesting();
}

/*---------------------------------------------------------------------------*/
/*                                                                           */
/*                              User Control Task                            */
/*                                                                           */
/*  This task is used to control your robot during the user control phase of */
/*  a VEX Competition.                                                       */
/*                                                                           */
/*  You must modify the code to add your own robot specific commands here.   */
/*---------------------------------------------------------------------------*/


task usercontrol()
{
while(true)
	{
		//Robot Movement
		motor[leftBase] = (vexRT[Ch2] + vexRT[Ch1])/2;
		motor[rightBase] = (vexRT[Ch2] - vexRT[Ch1])/2;

		motor[leftBase] = (vexRT[Ch3] + vexRT[Ch4])/1;
		motor[rightBase] = (vexRT[Ch3] - vexRT[Ch4])/1;

		//Intake Controls
		if(vexRT[Btn5U] == 1)
		{
			intakeStraightUp();
		}
		if(vexRT[Btn5D] == 1)
		{
			intakeStraightDown();
		}

		/*Intake 2
		if(vexRT[Btn5U] == 1)
		{
		motor[leftIntake] = 90;
		motor[rightIntake] = 90;
		}
		if(vexRT[Btn5D] == 1)
		{
		motor[leftIntake] = -90;
		motor[rightIntake] = -90;
		}*/

		/*//Claw Controls
		if(vexRT[Btn6U] == 1)
		{
		motor[clawMotor] = 127;
		}
		else if(vexRT[Btn6D] == 1)
		{
		motor[clawMotor] = -127;
		}
		else
		{
		motor[clawMotor] = 0;
		}*/
		/*
		//Lift Controls
		if(vexRT[Btn6U] == 1)
		{
		liftStraight();
		/*motor[rightLift] = normLift;
		motor[leftLift] = normLift;
		}
		else if(vexRT[Btn6D] == 1)
		{
		motor[rightLift] = -normLift;
		motor[leftLift] = -normLift;
		}
		else
		{
		motor[rightLift] = 0;
		motor[leftLift] = 0;
		}
		*/
    UserControlCodePlaceholderForTesting();
  }
}
