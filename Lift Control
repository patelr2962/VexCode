#pragma config(Sensor, in1,    leftPmeter,     sensorPotentiometer)
#pragma config(Sensor, in2,    rightPmeter,    sensorPotentiometer)
#pragma config(Sensor, in3,    Gyro,           sensorGyro)
#pragma config(Sensor, dgtl1,  leftEncoder,    sensorQuadEncoder)
#pragma config(Sensor, dgtl3,  rightEncoder,   sensorQuadEncoder)
#pragma config(Motor,  port1,           clawMotor,     tmotorVex393_HBridge, openLoop)
#pragma config(Motor,  port2,           leftBase,      tmotorVex393_MC29, openLoop, driveLeft, encoderPort, dgtl1)
#pragma config(Motor,  port3,           leftLift,      tmotorVex393_MC29, openLoop, reversed)
#pragma config(Motor,  port6,           rightLift,     tmotorVex393_MC29, openLoop)
#pragma config(Motor,  port7,           rightBase,     tmotorVex393_MC29, openLoop, driveRight, encoderPort, dgtl3)
#pragma config(Motor,  port10,          intakeMotor,   tmotorVex393_HBridge, openLoop)
//*!!Code automatically generated by 'ROBOTC' configuration wizard               !!*//

int liftaverage = SensorValue[leftPmeter] + SensorValue[rightPmeter];
int lifttarget = liftaverage;
int liftPIDtoggler = 1;
float liftholdvalue = 0;

void liftup (int speed)
{
	motor[port3]= speed;
	motor[port6]= speed;
}

void liftdown (int speed)
{
	motor[port3]= -(speed);
	motor[port6]= -(speed);
}

void liftcontrol()
{
	int liftupperbound = 5500 /*Find amount during tests*/; 
	int liftlowerbound = 2400 /*Find amount during tests*/;
	
	liftaverage = SensorValue[leftPmeter] + SensorValue[rightPmeter];

	if (liftaverage < liftlowerbound && liftaverage > 500)
	{
		if (vexRT[Btn6U] == 1)
		{
			liftup (127);
			lifttarget = liftaverage;
		}
		else if (vexRT[Btn6D] == 1)
		{
			liftdown (127);
			lifttarget = liftaverage;
		}
		else
		{
			if (vexRT[Ch2Xmtr2] > 10)
			{
				liftup(vexRT[Ch2Xmtr2]);
				lifttarget = liftaverage;
			}
			else if (vexRT[Ch2Xmtr2] < -10)
			{
				liftdown (127);
				lifttarget = liftaverage;
			}
			else
			{
				liftup (-20);
			}
		}
	}
	else if (liftaverage > liftupperbound)
	{
		if (vexRT[Btn6D] == 1)
		{
			liftdown (80) ;
			lifttarget = liftaverage;
		}
		else if (vexRT[Btn6U] == 1)
		{
			liftup (20);
			lifttarget = liftaverage;
		}
		else
		{
			if (vexRT[Ch2Xmtr2] > 10)
			{
				liftup(20);
				lifttarget = liftaverage;
			}
			else if (vexRT[Ch2Xmtr2] < -10)
			{
				liftdown (vexRT[Ch2Xmtr2]);
				lifttarget = liftaverage;
			}
			else
			{
				if (liftPIDtoggler == 1)
				{
					liftup (liftholdvalue);
				}
				else
				{
					liftup (0);
				}
			}
		}
	}
	else
	{
		if (vexRT[Btn6U] == 1)
		{
			liftup (127) ;
			lifttarget = liftaverage;
		}
		else if (vexRT[Btn6D] == 1)
		{
			lifttarget = liftaverage;
			if (liftPIDtoggler == 1)
			{
				liftdown (127);
			}
			else
			{
				liftdown (80);
			}
		}
		else
		{
			if (abs(vexRT[Ch2Xmtr2]) > 10)
			{
				liftup (vexRT[Ch2Xmtr2]);
				lifttarget = liftaverage;
			}
			else
			{
				if (liftPIDtoggler == 1)
				{
					liftup (liftholdvalue);
				}
				else
				{
					liftup (0);
				}
			}
		}
	}
	if (liftaverage < 2200)
	{
		liftaverage = 2100;
	}
}

task PIDliftcontrol()
{
	float Kp = 0.4/*Find amount during tests*/;
	float Kd = 1.2/*Find amount during tests*/;
	float Ki = 0.007/*Find amount during tests*/;

	float error;

	float proportion;
	float derivative;
	int lastError;
	float integral;
	float integralRaw;

	int integralActiveZone = 200/*Find amount during tests*/;
	float integralPowerLimit = 40/*Find amount during tests*/;

	float speedProfile;

	while (true)
	{
		error = lifttarget-liftaverage;//calculate error

		proportion = Kp*error; //calculate proportion

		derivative = Kd*(error-lastError);  //calculate the derivative
		lastError  = error;

		if (abs(error) < integralActiveZone && error != 0) //calculate integral
		{
			integralRaw = integralRaw+error;
		}
		else if (error == 0)
		{
			integralRaw = 0;
		}
		else
		{
			integralRaw = 0;
		}

		if (integralRaw > integralPowerLimit)
		{
			integralRaw = integralPowerLimit;
		}
		else if (integralRaw < -(integralPowerLimit))
		{
			integralRaw = -(integralPowerLimit);
		}

		if (vexRT[Btn6U] == 1 || vexRT[Btn6D] == 1)
		{
			integralRaw = 0;
		}

		integral = Ki*integralRaw;

		if (vexRT[Btn6U] == 1 || vexRT[Btn6D] == 1 || abs(vexRT[Ch2Xmtr2])>7)
		{
			clearTimer(T3);
		}
		if (time1[T3] < 1000)
		{
			lifttarget = SensorValue[leftPmeter] + SensorValue[rightPmeter];
			if (SensorValue[leftPmeter]+SensorValue[rightPmeter] > 2200)
			{
				speedProfile = 20;
			}
			else
			{
				speedProfile = -20;
			}

		}
		else
		{
			if (SensorValue[leftPmeter]+SensorValue[leftPmeter] > 2200)
			{
				speedProfile = 10;
			}
			else
			{
				speedProfile = 0;
			}
		}

		liftholdvalue = proportion+derivative+integral+speedProfile; //calculate output

		if (liftholdvalue > 127)
		{
			liftholdvalue = 127;
		}
		else if (liftholdvalue < -127)
		{
			liftholdvalue = -127;
		}

		wait1Msec (20);
	}
}

task main()
{
	startTask (PIDliftcontrol);
	while(true)
	{
		wait1Msec(20);
	}
}
